# Hand crafted tests for GNU M4.                               -*- Autotest -*-
# Copyright 2001 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.


AT_BANNER([Module support.])


## --------- ##
## modfreeze ##
## --------- ##

AT_SETUP([Freezing modules])

AT_DATA([[frozen.m4]],
[[divert(1)dnl
define(`test', `local::`test'')dnl
define(`test1', defn(`test'))dnl
->test
load(`modtest')
define(`test2', defn(`test'))dnl
->test
load(`shadow')
define(`test3', defn(`test'))dnl
->test
]])

AT_DATA([[unfrozen.m4]],
[[undivert(1)dnl
test1
test2
test3
]])

# First generate the `expout' ouput by running over the sources before
# freezeing.
AT_CHECK_M4([-m load frozen.m4 unfrozen.m4], 0,
            [stdout], [stderr])

mv stdout expout
mv stderr experr

# Now freeze the first source file.
AT_CHECK_M4([-m load -F frozen.m4f frozen.m4], 0,
            [ignore], [ignore])

# Now rerun the original sequence, but using the frozen file.
AT_CHECK_M4([-R frozen.m4f unfrozen.m4], 0,
            [expout], [experr])

AT_CLEANUP([frozen.m4f])



## ---------------------------- ##
## Exercising the test module.  ##
## ---------------------------- ##

# AT_CHECK_M4_MODTEST(TITLE, ENV-VARS, M4-OPTIONS)
# ------------------------------------------------
# Skip if modtest is not present (we are not in the package).
m4_define([AT_CHECK_M4_MODTEST],
[AT_SETUP([$1])
AT_KEYWORDS([module])

AT_CHECK([test -f $top_builddir/modules/modtest.la || exit 77])

AT_DATA([input.m4],
[[load(`modtest')
test
Dumpdef: dumpdef(`test').
unload(`modtest')
test
Dumpdef: dumpdef(`test').
]])

AT_CHECK([$2 m4 -m load -d input.m4 $3], 0,
[[
Test module called.
Dumpdef: .

test
Dumpdef: .
]],
[[Test module loaded.
test:	<test>
Test module unloaded.
m4: input.m4: 6: Warning: dumpdef: undefined name: test
]])

AT_CLEANUP
])



AT_CHECK_M4_MODTEST([--module-directory: absolute path],
                    [], [-M $top_buildpath/modules])

AT_CHECK_M4_MODTEST([--module-directory: relative path],
                    [], [-M $top_builddir/modules])

AT_CHECK_M4_MODTEST([M4MODPATH: absolute path],
                    [M4MODPATH=$top_buildpath/modules], [])

AT_CHECK_M4_MODTEST([M4MODPATH: relative path],
                    [M4MODPATH=$top_builddir/modules], [])

AT_CHECK_M4_MODTEST([LTDL_LIBRARY_PATH: absolute path],
                    [LTDL_LIBRARY_PATH=$top_buildpath/modules], [])

AT_CHECK_M4_MODTEST([LTDL_LIBRARY_PATH: relative path],
                    [LTDL_LIBRARY_PATH=$top_builddir/modules], [])




## ------ ##
## shadow ##
## ------ ##

AT_SETUP([modules: shadow])

AT_DATA([[input.m4]],
[[# no modules loaded yet
test
shadow

# define our own macros for `test' and `shadow'
define(`test', `local::`test'')
define(`shadow', `local::`shadow'')
test
shadow

# module Shadow defines `shadow' and `test' macros
load(`shadow')
dumpdef(`test')
dumpdef(`shadow')
test
shadow

# save the definition of `test' from the Shadow module
define(`Shadow::test', defn(`test'))

# module Modtest also defines a `test' macro
load(`modtest')
dumpdef(`test')
dumpdef(`shadow')
test
shadow

# Reloading Shadow shouldn't affect anything
load(`shadow')
dumpdef(`test')
dumpdef(`shadow')
test
shadow

# Unloading Modtest will unshadow the test definition in Shadow
unload(`modtest')
dumpdef(`test')
dumpdef(`shadow')
test
shadow

# Unloading Shadow once has no effect (we loaded it twice)
unload(`shadow')
dumpdef(`test')
dumpdef(`shadow')
test
shadow

# Unloading Shadow again will revert to copying `test' and the local
# `shadow' macro.
unload(`shadow')
test
shadow
]])

AT_DATA([[expout]],
[[# no modules loaded yet
test
shadow

# define our own macros for `test' and `shadow'


local::test
local::shadow

# module Shadow defines `shadow' and `test' macros
Shadow module loaded.


Shadow::test called.
Shadow::shadow called.

# save the definition of `test' from the Shadow module


# module Modtest also defines a `test' macro



Test module called.
Shadow::shadow called.

# Reloading Shadow shouldn't affect anything



Test module called.
Shadow::shadow called.

# Unloading Modtest will unshadow the test definition in Shadow



Shadow::test called.
Shadow::shadow called.

# Unloading Shadow once has no effect (we loaded it twice)



Shadow::test called.
Shadow::shadow called.

# Unloading Shadow again will revert to copying `test' and the local
# `shadow' macro.

local::test
local::shadow
]])

AT_DATA([[experr]],
[[test:	<test>
shadow:	<shadow>
Test module loaded.
test:	<test>
shadow:	<shadow>
test:	<test>
shadow:	<shadow>
Test module unloaded.
test:	<test>
shadow:	<shadow>
test:	<test>
shadow:	<shadow>
]])

AT_CHECK_M4([-m load input.m4], 0,
            [expout], [experr])

AT_CLEANUP



## ------ ##
## unload ##
## ------ ##

AT_SETUP([modules: unload])

AT_DATA([[input.m4]],
[[test
__test__
load(`modtest')
test
__test__
load(`shadow')
test
__test__
unload(`modtest')
test
__test__
load(`modtest')
test
__test__
unload(`modtest')
test
__test__
unload(`shadow')
test
__test__
]])

AT_DATA([[expout]],
[[test
__test__

Test module called.
modtest
Shadow module loaded.
Shadow::test called.
shadow

Shadow::test called.
shadow

Test module called.
modtest

Shadow::test called.
shadow

test
__test__
]])

AT_DATA([[experr]],
[[Test module loaded.
Test module unloaded.
Test module loaded.
Test module unloaded.
]])


AT_CHECK_M4([-m load input.m4], 0, expout, experr)

AT_CLEANUP



## ----------------------- ##
## module symbol importing ##
## ----------------------- ##

# Importing a symbol from a not yet loaded module

AT_SETUP([modules: importing])

AT_DATA([[input.m4]],
[[import
load(`import')
import
unload(`modtest')
import
symbol_fail
module_fail
]])

AT_DATA([[expout]],
[[import

import::import called.

import::import called.
import::symbol_fail called.
]])

AT_DATA([[experr]],
[[Test module loaded.

TRUE
Test module unloaded.
Test module loaded.

TRUE
m4: input.m4: 6: Warning: cannot load symbol `no_such' from module `modtest'
m4: input.m4: 7: cannot open module `no_such': no_such.so: cannot open shared object file: No such file or directory
]])

AT_CHECK_M4([-m load input.m4 2>acterr], 1, expout, ignore)

sed '/^m4: input.m4: 7:/ {
    s,\(7:[[^:]]*:\).*$,\1 no_such.so: cannot open shared object file: No such file or directory, }' < acterr > editerr
$at_diff experr editerr || echo 1 > $at_status_file

AT_CLEANUP



## -------------------- ##
## trace module symbols ##
## -------------------- ##

# The trace bit should not be lost if a builtin is unloaded from
# memory and then redefined by a subsequent load.

AT_SETUP([modules: trace])

AT_DATA([[input.m4]],
[[test
load(`shadow')
test
unload(`shadow')
test
load(`shadow')
test
]])

AT_DATA([[expout]],
[[test
Shadow module loaded.
Shadow::test called.

test
Shadow module loaded.
Shadow::test called.
]])

AT_DATA([[experr]],
[[m4trace: -1- test -> `Shadow::`test' called.'
m4trace: -1- test -> `Shadow::`test' called.'
]])


AT_CHECK_M4([-m load -t test input.m4], 0, expout, experr)

AT_CLEANUP
