#! /bin/sh
#
# gnulib-import (GNU m4) version 0.2
# Written by Gary V. Vaughan <gary@gnu.org>

# Copyright (C) 2003, 2004 Free Software Foundation, Inc.
#
# This file is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# Usage: $progname [OPTION]...

#           --debug          enable verbose shell tracing
# -n        --dry-run        don't write out any files
# -1        --list-modules   list all dependent modules and exit
# -v        --verbose        run in verbose mode
#           --version        print version information
# -h,-?     --help           print short or long help message

# Extract a list of gnulib modules used from project configure.ac, and
# copy the relevant files from an adjacent gnulib directory.

# Report bugs to <gary@gnu.org>

: ${TMPDIR="/tmp"}
: ${SED="sed"}
: ${AUTOCONF="autoconf"}
: ${GNULIB_DIR="$HOME/devel/savannah/gnulib"}
: ${CONFIGDIR=".."}
: ${destdir="."}
: ${DEST_TRANSFORM='s:^m4/:acm4/:;s:^lib/:m4/:'}
: ${LIB_TRANSFORM='s:^lib_:libgnu_la_:'}

dirname="s,/[^/]*$,,"
basename="s,^.*/,,g"

# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
# is ksh but when the shell is invoked as "sh" and the current value of
# the _XPG environment variable is not equal to 1 (one), the special
# positional parameter $0, within a function call, is the name of the
# function.
progpath="$0"

# The name of this program:
progname=`echo "$progpath" | $SED $basename`
PROGRAM=gnulib-import

# Global variables:
EXIT_SUCCESS=0
EXIT_FAILURE=1

opt_dryrun=false
opt_list_modules=false
opt_verbose=false

exit_cmd=:

gnulibtool_magic="## This file generated automatically by $progname "

# func_echo arg...
# Echo program name prefixed message.
func_echo ()
{
    echo $progname: ${1+"$@"}
}

# func_error arg...
# Echo program name prefixed message to standard error.
func_error ()
{
    echo $progname: ${1+"$@"} 1>&2
}

# func_fatal_error arg...
# Echo program name prefixed message to standard error, and exit.
func_fatal_error ()
{
    func_error ${1+"$@"}
    exit $EXIT_FAILURE
}

# func_verbose arg...
# Echo program name prefixed message in verbose mode only.
func_verbose ()
{
    $opt_verbose && func_error ${1+"$@"}
}

# func_fatal_help arg...
# Echo program name prefixed message to standard error, followed by
# a help hint, and exit.
func_fatal_help ()
{
    func_error ${1+"$@"}
    func_fatal_error "Try \`$progname --help' for more information."
}

# func_missing_arg argname
# Echo program name prefixed message to standard error and set global
# exit_cmd.
func_missing_arg ()
{
    func_error "missing argument for $1"
    exit_cmd=exit
}

# Echo short help message to standard output and exit.
func_usage ()
{
    $SED '/^# Usage:/,/# -h/ {
        s/^# //; s/^# *$//;
	s/\$progname/'$progname'/;
	p;
    }; d' < "$progpath"
    echo
    echo "run \`$progname --help | more' for full usage"
    exit $EXIT_SUCCESS
}

# func_help
# Echo long help message to standard output and exit.
func_help ()
{
    $SED '/^# Usage:/,/# Report bugs to/ {
        s/^# //; s/^# *$//;
	s/\$progname/'$progname'/;
	p;
     }; d' < "$progpath"
    exit $EXIT_SUCCESS
}

# func_version
# Echo version message to standard output and exit.
func_version ()
{
    $SED '/^# '$PROGRAM' (GNU /,/# warranty; / {
        s/^# //; s/^# *$//;
        s/\((C)\)[ 0-9,-]*\( [1-9][0-9]*\)/\1\2/;
        p;
     }; d' < "$progpath"
     exit $EXIT_SUCCESS
}

# Parse options once, thoroughly.  This comes as soon as possible in
# the script to make things like `gnulib-import --version' happen quickly.
{
  # sed scripts:
  my_sed_single_opt='1s/^\(..\).*$/\1/;q'
  my_sed_single_rest='1s/^..\(.*\)$/\1/;q'
  my_sed_long_opt='1s/^\(--[^=]*\)=.*/\1/;q'
  my_sed_long_arg='1s/^--[^=]*=//'

  while test $# -gt 0; do
    opt="$1"
    shift
    case $opt in
      --debug)		func_echo "enabling shell trace mode"
			set -x
			;;

      -n|--dryrun)      opt_dryrun=:			;;
      -1|--list-modules)
	    		opt_list_modules=:		;;
      -v|--verbose)	opt_verbose=:			;;

      # Separate optargs to long options:
      NYI)
			arg=`echo "$opt" | $SED "$my_sed_long_arg"`
			opt=`echo "$opt" | $SED "$my_sed_long_opt"`
			set -- "$opt" "$arg" ${1+"$@"}
			;;

      # Separate optargs to short options:
      NYI)
			arg=`echo "$opt" |$SED "$my_sed_single_rest"`
			opt=`echo "$opt" |$SED "$my_sed_single_opt"`
			set -- "$opt" "$arg" ${1+"$@"}
			;;

      # Separate non-argument short options:
      -1*|-h*|-n*|-v*)
			rest=`echo "$opt" |$SED "$my_sed_single_rest"`
			opt=`echo "$opt" |$SED "$my_sed_single_opt"`
			set -- "$opt" "-$rest" ${1+"$@"}
			;;

      -\?|-h)		func_usage					;;
      --help)		func_help					;;
      --version)	func_version					;;
      --)		break						;;
      -*)		func_fatal_help "unrecognized option \`$opt'"	;;
      *)		set -- "$opt" ${1+"$@"};      break		;;
    esac
  done
}

# func_get_dependencies mod [...]
func_get_dependencies ()
{
  my_modules=
  for my_mod in ${1+"$@"}; do
    my_modules="$my_modules
$my_mod
`( cd $GNULIB_DIR && ./gnulib-tool --extract-dependencies $my_mod )`"
  done

  echo "$my_modules" | sort | uniq | sed '/^[ 	]*$/d'
}

# func_update_file dest
func_update_file ()
{
  dest="$1"

  src="${dest}T"
  (
    cd "$destdir"

    if test -f $dest; then
      if cmp -s $src $dest; then
	# Files are the same: remove SRC
	rm -f $src
      elif cat $dest | grep "^$gnulibtool_magic" >/dev/null 2>&1; then
        # Files differ, and contain correct magic: update
	$opt_dryrun || mv -f $src $dest
	func_echo "updating... $dest"
      else
	# DEST does not contain correct magic: ignore
	func_echo "ignoring... $dest (user edits)"
      fi
    else
      # DEST does not yet exist: create it
      $opt_dryrun || { echo "$gnulibtool_magic" > $dest; cat $src >> $dest; }
      func_echo "creating... $dest"
    fi

    $opt_dryrun || rm -f $src
  )
}

# func_update_makerules module ...
# import Makefile snippets
func_update_makerules ()
{
  dest=`echo "lib/gnulib.am" | sed $DEST_TRANSFORM`

  rm -f "$destdir/${dest}T"
  for mod in ${1+"$@"}
  do
    echo "## ((( gnulib module $mod"
    (
      cd $GNULIB_DIR
      ./gnulib-tool --extract-automake-snippet $mod
    ) | sed $LIB_TRANSFORM
    echo "## ))) gnulib module $mod"
  done >> "$destdir/${dest}T"
  func_update_file "$destdir/$dest"
}

# func_update_configury module ...
func_update_configury ()
{
  dest=
  for dir in . ..
  do
    test -f "$dir/configure.in" && dest="$dir/configure.in"
    test -f "$dir/configure.ac" && dest="$dir/configure.ac"
    test -f "$dest" && break
  done
  cp $dest $dest.orig

  for mod in ${1+"$@"}
  do
    fragment=`( cd $GNULIB_DIR; \
      ./gnulib-tool --extract-autoconf-snippet $mod; \
      )  | sed '/^[ 	]*$/d'`
    magic="gnulib module $mod"

    if grep "^dnl <-- override $magic[ 	]*\$" "$dest" >/dev/null 2>&1
    then
      func_error "WARNING: overridden m4 for $mod unchanged"
    elif grep "^dnl ((( $magic[ 	]*\$" "$dest" >/dev/null 2>&1
    then
      func_verbose "Updating m4 for $mod in $dest"
      awk "/^dnl \(\(\( $magic[ 	]*$/,/^dnl \)\)\) $magic[ 	]*$/ {
        if (DONE != 1)
	  {
	    print \"dnl ((( $magic\";
	    if (length(\"$fragment\") > 0) print \"$fragment\";
	    print \"dnl ))) $magic\";
	    DONE = 1;
	  }
	next;
      }
      { print; }" "$dest" > "${dest}T"
      mv -f "${dest}T" "$dest"
    else
      func_echo "WARNING: please move new $mod fragment in $dest"
      echo "dnl ((( $magic" >> "$dest"
      echo "$fragment" >> "$dest"
      echo "dnl ((( $magic" >> "$dest"
    fi
  done
}

# func_update_gnulib_files module ...
func_update_gnulib_files ()
{
  for mod in ${1+"$@"}
  do
    # collect filelist
    filelist="$filelist
`( cd $GNULIB_DIR && ./gnulib-tool --extract-filelist $mod )`"
  done
  all_files=`echo "$filelist" | sort | uniq`

  for file in $all_files; do
    # import files
    cp -f $GNULIB_DIR/$file $destdir/`echo $file | sed $DEST_TRANSFORM`
    func_echo "importing... $file"
  done
}

# Get a list of named modules
func_verbose "extracting required module names"
mymodules=${*-`cd $CONFIGDIR; $AUTOCONF --trace=m4_GNULIB_MODULES |sed 's,^.*:,,g'`}

# Calculate list of all modules
func_verbose "calculating module dependencies"
modules=`func_get_dependencies $mymodules`
while :; do
    all_modules=`func_get_dependencies $modules`
    test "X$modules" = "X$all_modules" && break
    modules="$all_modules"
done

if $opt_list_modules; then
  echo "$all_modules"
  exit $EXIT_SUCCESS
fi

# Update gnulib sources and macros
func_verbose "updating gnulib files"
func_update_gnulib_files $all_modules

# Update makefile fragments
func_verbose "extracting make fragments"
func_update_makerules $all_modules

# Update autoconf fragments
func_verbose "extracting autoconf fragments"
func_update_configury $all_modules

exit $EXIT_SUCCESS

# Local Variables:
# mode:shell-script
# sh-indentation:2
# End:
