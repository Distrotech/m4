# Hand crafted tests for GNU M4.                               -*- Autotest -*-
# Copyright (C) 2006 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.


AT_BANNER([Freezing state.])

## ---------------- ##
## loading format 1 ##
## ---------------- ##

AT_SETUP([loading format 1])
AT_KEYWORDS([frozen])

m4_if([
Note: frozen.m4f was obtained by deleting unneeded lines from the output of
a version of m4 1.4.5 with changeword support.  Deleting lines is in effect
equivalent to using undefine(name) in the input.  This test ensures we
behave well with the old format, including \ parsing, disappearing builtins
(okay so long as the input does not try to use them), and restoring sane
defaults for features that were only added in version 2 frozen format.

$ m4 --version | head -n1
GNU M4 1.4.5
$ cat frozen.m4
divert(`-1')
define(`foo', `\FOO')
pushdef(`foo', `bar')
define(`my_define', defn(`define'))
define(`my_changeword', defn(`changeword'))
pushdef(`my_define', `define')
pushdef(`my_define', defn(`define'))
divert(`1')dnl
foo
divert`'dnl
changequote([,])dnl
changecom([/*], [*/])dnl
dnl Implied sequence of undefine(`name') due to hand-edits
$ m4 -F frozen.m4f frozen.m4
$
])
AT_DATA([frozen.m4f],
[[# This is a frozen state file generated by GNU M4 1.4.5
V1
Q1,1
[]
C2,2
/**/
F6,6
popdefpopdef
F13,10
my_changewordchangeword
F9,6
my_definedefine
T9,6
my_definedefine
F9,6
my_definedefine
T3,4
foo\FOO
T3,3
foobar
F3,3
dnldnl
D1,4
bar

D0,0

# End of frozen state file
]])

AT_DATA([input.m4],
[[foo /* foo */ popdef([foo])foo
my_define([bar], [1])[]popdef([my_define]) bar
my_define([bar], [2])[]popdef([my_define]) bar
my_define([bar], [3])[]popdef([my_define]) bar
my_define([bar], [4])[]popdef([my_define]) bar
]])

AT_CHECK_M4([-R frozen.m4f input.m4], [0],
[[bar /* foo */ \FOO
 1
define 1
 3
my_define(bar, 4) 3
bar
]],
[[m4:input.m4:5: Warning: popdef: undefined name: my_define
]])

AT_CLEANUP


## -------------------------- ##
## Reloading unknown builtins ##
## -------------------------- ##

AT_SETUP([reloading unknown builtin])
AT_KEYWORDS([frozen])

AT_DATA([[empty.m4]])

# Freeze default state.
AT_CHECK_M4([-F frozen.m4f empty.m4])

# Add an unknown builtin.
echo 'F1,1' >> frozen.m4f
echo 'ab' >> frozen.m4f

AT_DATA([[input.m4]],
[[dnl The macro is defined; checking this is safe
ifdef(`a', `yes', `no')
dnl Grabbing the definition must warn; and the copy is the empty string
define(`c', defn(`a'))
dnl Invoking the macro directly must warn
a
dnl Invoking it indirectly must warn
indir(`a')
dnl The copy is a text string, not a placeholder
c
dnl Since it is defined, it must have a definition
dumpdef(`a', `c')
dnl Deleting it is safe
popdef(`a')
a
]])

AT_CHECK_M4([-R frozen.m4f input.m4], 0,
[[yes






a
]],
[[m4:input.m4:4: Warning: a: builtin `b' requested by frozen file not found
m4:input.m4:6: Warning: a: builtin `b' requested by frozen file not found
m4:input.m4:8: Warning: a: builtin `b' requested by frozen file not found
a:	<placeholder for b>
c:	`'
]])

AT_CLEANUP

## ---------------------- ##
## Freezing regexp syntax ##
## ---------------------- ##

AT_SETUP([regexp syntax])
AT_KEYWORDS([frozen])

# Check that regular expression syntax is maintained across freeze baundaries.

AT_DATA([[frozen.m4]],
[[changeresyntax(`POSIX_EXTENDED')dnl
]])

AT_DATA([[unfrozen.m4]],
[[regexp(`GNUs not Unix', `\w(\w*)$')
regexp(`GNUs not Unix', `\w\(\w*\)$', `GNU_M4')
]])

# First generate the `expout' output by running over the sources before
# freezing.
AT_CHECK_M4([frozen.m4 unfrozen.m4], 0,
	    [stdout], [stderr])

mv stdout expout
mv stderr experr

# Now freeze the first source file.
AT_CHECK_M4([-F frozen.m4f frozen.m4], 0,
	    [ignore], [ignore])

# Now rerun the original sequence, but using the frozen file.
AT_CHECK_M4([-R frozen.m4f unfrozen.m4], 0,
	    [expout], [experr])

AT_CLEANUP([frozen.m4f])
